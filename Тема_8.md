# Тема 8. Основы ООП 
Отчет по Теме #8 выполнил:
- Шашков Владимир Дмитриевич
- ИВТ-22-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями

```python
class car: #Создание класса
    def __init__(self, manufac, model): #Устанавливание значений атрибутов класса
        self.manufac=manufac #Создание ссылки на текущий экземпляр класса
        self.model=model 

my_car=car("Audi", "A6") #Создание экземпляра класса
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/L1.8.png)

## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль

```python
class car: #Создание класса
    def __init__(self, manufac, model): #Устанавливание значений атрибутов класса
        self.manufac=manufac #Создание ссылки на текущий экземпляр класса
        self.model=model 
    def drive(self): #Создание метода класса
        print(f"Driving {self.manufac} {self.model}")

my_car=car("Audi", "A6") #Создание экземпляра класса
my_car.drive() #Вызов метода класса
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/L2.8.png)

## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться

```python
class car: #Создание класса
    def __init__(self, manufac, model): #Устанавливание значений атрибутов класса
        self.manufac=manufac #Создание ссылки на текущий экземпляр класса
        self.model=model 
    def drive(self): #Создание метода класса
        print(f"Driving {self.manufac} {self.model}")

my_car=car("Audi", "A6") #Создание экземпляра класса
my_car.drive() #Вызов метода класса

class electricCar(car): #Создание класса-наследника
    def __init__(self, manufac, model, capacity): #Устанавливание значений атрибутов класса-наследника
        super().__init__(manufac, model) #Вызов метода инициализации родительского суперкласса
        self.capacity=capacity
    
    def charge(self): #Создание метода класса-наследника
        print(f"Charging {self.manufac} {self.model} with {self.capacity} kWh charger")

my_el_car=electricCar('Tesla', 'Model X', 100) #Создание экземпляра класса-наследника
my_el_car.drive()
my_el_car.charge()
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/L3.8.png)

## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль

```python 
class car: #Создание класса
    def __init__(self, manufac, model): #Устанавливание значений атрибутов класса
        self._manufac=manufac #protected атрибут
        self.__model=model #private атрибут

    def drive(self): #Создание метода класса
        print(f"Driving {self._manufac} {self.__model}")

my_car=car("Audi", "A6") #Создание экземпляра класса
print(my_car._manufac)
my_car.drive() #Вызов метода класса
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/L4.8.png)

## Лабораторная работа №5
### Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль

```python
class Shape: #Создание Основного класса
    def Area(self):
        pass
class Rectangle(Shape): #Создание Класса-наследника
    def __init__ (self, w, h): #Устанавливание значений атрибутов класса
        self.w=w
        self.h=h
    
    def Area(self): #Создание Унаследованого метода
        return self.w*self.h

class Circle(Shape): #Создание Класса-наследника
    def __init__ (self, r):
        self.r=r
    
    def Area(self): #Создание Унаследованого метода
        return 3.14*self.r*self.r
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/L5.8.png)

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли

```python
class LegionesSkitarii:
    def __init__(self, part1, part2, part3, part4):
        self.part1 = part1
        self.part2 = part2
        self.part3 = part3
        self.part4 = part4

LegionesS = LegionesSkitarii('Fabricator General', 'Fabricator Locum', 'Priests of the cult Mechanicus', 'Stighia 8')
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/tree/Тема_8)

## Выводы
1. `class LegionesSkitarii:`: В Python класс можно создать командой ```class```

## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли

```python
class LegionesSkitarii:
    def __init__(self, part1, part2, part3, part4):
        self.part1 = part1
        self.part2 = part2
        self.part3 = part3
        self.part4 = part4

    def Skitarii(self):
        print(f"{self.part1} the forge world {self.part4}c sends it to a military company {self.part3}")

LegionesS = LegionesSkitarii('Fabricator General', 'Fabricator Locum', 'Priests of the cult Mechanicus', 'Stighia 8')
LegionesS.Skitarii()
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/S2.8.png)

## Выводы
1. `def __init__(self, mate1, mate2, mate3, mate4):`: Чтобы создать атрибут класса в Python, его нужно определить вне метода ```init```.

## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли

```python
class LegionesSkitarii:
    def __init__(self, part1, part2, part3, part4):
        self.part1 = part1
        self.part2 = part2
        self.part3 = part3
        self.part4 = part4

    def Skitarii(self):
        print(f"{self.part1} the forge world {self.part4}c sends it to a military company {self.part3}")

LegionesS = LegionesSkitarii('Fabricator General', 'Fabricator Locum', 'Priests of the cult Mechanicus', 'Stighia 8')
LegionesS.Skitarii()

class Objective(LegionesSkitarii):
    def __init__(self, part1, part2, part3, part4):
        super().__init__(part1, part2, part3, part4)
    def objective(self):
        print(f'Objective military company capture {self.part1}, Ark of the Mechanicus {self.part2}')

team_lead=Objective('Araphis7', 'The Iron Ghost', "Gastaf Gediatrix", "Kode2-13-4")
team_lead.objective()
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/S3.8.png)

## Выводы
1. `class Objective(LegionesSkitarii):` Для реализации наследования необходимо создать класс и указать в скобках класс-родитель

## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли

```python
class LegionesSkitarii:
    def __init__(self, part1, part2, part3, part4):
        self.__part1 = part1
        self._part2 = part2
        self.part3 = part3
        self.__part4 = part4

    def Skitarii(self):
        print(f"{self.__part1} the forge world {self.__part4}c sends it to a military company {self.part3}")

LegionesS = LegionesSkitarii('Fabricator General', 'Fabricator Locum', 'Priests of the cult Mechanicus', 'Stighia 8')
LegionesS.Skitarii()
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/S4.8.png)

## Выводы
1.`self.__part1 = part1` В Python модификаторы определяются при помощи ```_```

## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли

```python
class Shooting:
    def calculation(self):
        pass

class shot_1(Shooting):
    def calculation(self):
        print('100hp - 20hp * 4')

class shot_2(Shooting):
    def calculation(self):
        print('miss')

a = input()
if a == 1:
    sh = shot_1
    sh.calculation()
elif a != 2:
    sm = shot_2
    sm.calculation()
```

### Результат.
![Меню](https://github.com/FeugiantMortis/Software-engineering/blob/Тема_8/pic/S5.8.png)

## Выводы
1. Полиморфизм в Python — это способность выполнять одно и то же действие над объектами разных типов.
